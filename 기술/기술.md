html doc type / 참조타입
이벤트위임
prototype
extends 없이 상속받기
클로저
프로미스 에러 캐치방법
call,apply,bind
js 타입 기본형 참조형
이벤트루프 / 애니메이션 루프나 등등
use strict




### html doctype
* html 문서에서 가장 처음에 선언
* 작성된 html의 버전을 브라우저에게 제공하기 위함
* html5 : `<!DOCTYPE html>`, html4.01 : DTD 사용

### 버블링, 캡처링 : <a href="https://ko.javascript.info/bubbling-and-capturing" target="_blank">링크</a>
* 어떤 DOM에서 핸들러 이벤트 e가 발생하면 해당 DOM에서만 e가 발생하는게 아니라 `상위 DOM`들에서도 발생
* 캡처링->해당DOM->버블링 순으로 발동
* `e.target` 을 통해 정확히 이벤트가 발생한 DOM을 받아올 수 있음
* `this(=e.currentTarget)` 은 현재 요소로, 캡처링이나 버블링 과정에서 현재의 DOM을 받아올 수 있음
* `e.stopPropagation()` : 해당 e로는 더이상 버블링이 수행되지 않음 (사용 지양할 것)

### 실행 컨텍스트
* 실행할 코드의 환경 정보들을 모아놓은 추상적인 개념
* 함수를 실행하거나 블럭이 만들어지면 실행 컨텍스트가 새로 생성되어 콜스택에 쌓인다
* 전역 실행 컨텍스트는 가장 먼저 콜스택에 올라가는 컨텍스트
* 함수 실행 컨텍스트는 함수나 블럭이 호출되면 콜스택에 올라가는 컨텍스트

### 전역 스코프
* JS는 호스트 환경에 기본 내장된 스코프
* 브라우저 환경에선 `window`, Node.js 환경에선 `global` 등으로 불림
* `globalThis`라는 통일된 이름으로 부르자는 내용이 최근 JS 제안 목록에 추가되었으나 지원하지 않는 브라우저가 있을 수 있음
* `var`로 선언된 변수는 전역 스코프에 저장됨
* 전역 실행 컨텍스트의 `this`는 전역 스코프를 가리킴

### 렉시컬 스코프
* 함수나 블럭 코드가 <b>선언</b>될 때의 환경
* 코드 내부엔 수많은 렉시컬 스코프가 존재하며, <b>현재 실행중인 실행 컨텍스트에서의 렉시컬 스코프</b> 와 같이 말할 수 있음

### this
* this는 실행 컨텍스트가 생성될 때 바인딩됨 (즉 전역 실행 컨텍스트의 this는 전역 스코프)
* 일반 함수(or 클래스)의 this는 함수가 호출될 때 동적으로 바인딩되며, call apply bind를 통해 this를 특정 데이터로 바인딩할 수 있음
* 화살표 함수의 this는 지정할 수 없으며, 함수가 <b>선언된 곳</b>의 상위 스코프의 this를 가리킴

### call, apply, bind
* 함수에 this를 직접 바인딩할 수 있는 기능
* `(함수명).call(this, ...args)` 형태로 사용
* call과 apply의 차이점은 매개변수의 형식. call은 매개변수를 쭉 나열하지만 apply는 매개변수들을 하나의 배열로 묶어 전달
* bind는 call,apply와 달리 함수를 호출하지 않는다. 따라서 변수에 할당하고 나중에 활용하는식으로 사용한다. 매개변수 형식은 call과 같다.

### closure
* closure는 외부 렉시컬 스코프에 접근할 수 있는 함수
* JS의 함수는 외부 렉시컬 스코프에 접근할 수 있는 [[Environment]] 프로퍼티를 갖고 있음. 따라서 모든 JS의 함수는 closure임
* JS에서 closure의 활용은 주로 함수를 반환하는 함수에서 사용됨
  * 함수는 실행될 때 새로운 렉시컬 스코프가 생성되고, 이 렉시컬 스코프엔 매개변수와 내부에서 선언한 지역변수가 담김
  * 만약 함수가 내부의 다른 함수를 반환한다면, 반환된 내부 함수는 외부 렉시컬 스코프, 즉 외부 함수가 실행될 때 만들어진 렉시컬 스코프를 저장함
  * 함수에서 외부 렉시컬 스코프에 있는 프로퍼티를 변경하면 외부 렉시컬 스코프에서 변경됨
  * <b>위의 이유들로 인해 JS에서 closure의 활용은 같은 동작을 하지만 각자 다른 렉시컬 스코프를 가진 함수를 생성하는 용도로 많이 사용됨</b>
* 전역에 선언된 함수의 외부 렉시컬 스코프는 전역 스코프
  * 전역에서 선언된 함수 또한 closure가 맞지만, 전역 스코프는 하나이기 때문에 전역에서 선언된 함수는 모두 같은 외부 렉시컬 환경을 지님
  * 따라서 전역에서 선언된 함수는 각기 다른 외부 렉시컬 스코프를 갖는 closure로써 활용할 수는 없음


### hoisting 및 변수 처리
* 전역 실행 컨텍스트가 시작되는 순간 발생
* 변수명(식별자), 함수선언문으로 선언된 함수가 전역 스코프에 저장된다.
* 변수의 처리는 다음과 같은 순서로 이루어진다.
    1) 선언 단계 : 모든 변수가 호이스팅되어 실행 컨텍스트의 변수 리스트에 등록된다.
    2) 초기화 단계 : 변수 리스트에 등록된 변수를 위한 공간을 메모리에 할당한다. 할당된 후 해당 변수의 값은 undefined가 된다,
    3) 할당 단게 : 변수의 값을 특정 값으로 할당한다.
* var 로 선언한 변수는 선언과 초기화가 동시에 이루어진다.
* let, const로 선언한 변수는 호이스팅 단계에서 선언만 이루어지고, 실제 코드에 도달해야 초기화가 이루어진다.

### prototype
* JS의 기본 데이터 타입을 제외한 모든 데이터는 객체로 취급된다. 이 객체에는 prototype이라는 숨겨진 속성이 존재한다.
* prototype은 자신을 만들어낸 원형이다.
* 함수에도 prototype이 있다. 만약 함수의 prototype을 변경하면 모든 해당 함수를 참조하고 있던 참조함수들의 prototype 또한 변경된다.